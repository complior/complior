use ratatui::layout::Rect;
use ratatui::style::Style;
use ratatui::text::{Line, Span};
use ratatui::widgets::{Block, Borders, Paragraph, Wrap};
use ratatui::Frame;

use crate::app::App;
use crate::components::markdown;
use crate::theme;
use crate::types::{ScanResult, Zone};

/// Export status.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ExportStatus {
    None,
    Done(String),
    Error(String),
}

/// State for the Report View.
#[derive(Debug, Clone)]
pub struct ReportViewState {
    pub scroll_offset: u16,
    pub export_status: ExportStatus,
}

impl Default for ReportViewState {
    fn default() -> Self {
        Self {
            scroll_offset: 0,
            export_status: ExportStatus::None,
        }
    }
}

/// Map zone to human-readable label.
pub fn zone_label(zone: Zone) -> &'static str {
    match zone {
        Zone::Green => "GREEN (Compliant)",
        Zone::Yellow => "YELLOW (Partial)",
        Zone::Red => "RED (Non-compliant)",
    }
}

/// Generate compliance report as Markdown.
pub fn generate_report_markdown(scan: &ScanResult) -> String {
    let mut md = String::new();
    let zone = zone_label(scan.score.zone);

    md.push_str("# Compliance Report\n\n");

    // Executive Summary
    md.push_str("## Executive Summary\n\n");
    md.push_str(&format!(
        "- **Score:** {:.0}/100\n",
        scan.score.total_score
    ));
    md.push_str(&format!("- **Zone:** {zone}\n"));
    md.push_str(&format!("- **Project:** {}\n", scan.project_path));
    md.push_str(&format!("- **Scanned:** {}\n", scan.scanned_at));
    md.push_str(&format!("- **Files scanned:** {}\n", scan.files_scanned));
    md.push_str(&format!("- **Duration:** {}ms\n", scan.duration));
    md.push_str(&format!(
        "- **Checks:** {} total, {} passed, {} failed, {} skipped\n\n",
        scan.score.total_checks,
        scan.score.passed_checks,
        scan.score.failed_checks,
        scan.score.skipped_checks,
    ));

    // Category Scores
    if !scan.score.category_scores.is_empty() {
        md.push_str("## Category Scores\n\n");
        md.push_str("| Category | Score | Passed | Failed |\n");
        md.push_str("|----------|------:|-------:|-------:|\n");
        for cat in &scan.score.category_scores {
            md.push_str(&format!(
                "| {} | {:.0}% | {} | {} |\n",
                cat.category_name, cat.score, cat.passed, cat.failed,
            ));
        }
        md.push('\n');
    }

    // Critical Findings
    let critical: Vec<_> = scan
        .findings
        .iter()
        .filter(|f| matches!(f.severity, crate::types::Severity::Critical))
        .collect();

    if !critical.is_empty() {
        md.push_str("## Critical Findings\n\n");
        for f in &critical {
            let obl = f.obligation_id.as_deref().unwrap_or("N/A");
            let art = f.article_reference.as_deref().unwrap_or("N/A");
            md.push_str(&format!("### {obl}: {}\n\n", f.message));
            md.push_str(&format!("- **Article:** {art}\n"));
            md.push_str("- **Severity:** CRITICAL\n");
            if let Some(fix) = &f.fix {
                md.push_str(&format!("- **Fix:** {fix}\n"));
            }
            md.push('\n');
        }
    }

    // All Findings
    md.push_str("## All Findings\n\n");
    if scan.findings.is_empty() {
        md.push_str("No findings. All checks passed.\n\n");
    } else {
        md.push_str("| # | Check ID | Severity | Message |\n");
        md.push_str("|--:|----------|----------|--------|\n");
        for (i, f) in scan.findings.iter().enumerate() {
            md.push_str(&format!(
                "| {} | {} | {:?} | {} |\n",
                i + 1,
                f.check_id,
                f.severity,
                f.message,
            ));
        }
        md.push('\n');
    }

    // Remediation Plan
    let fixable: Vec<_> = scan.findings.iter().filter(|f| f.fix.is_some()).collect();
    if !fixable.is_empty() {
        md.push_str("## Remediation Plan\n\n");
        for (i, f) in fixable.iter().enumerate() {
            let obl = f.obligation_id.as_deref().unwrap_or("N/A");
            md.push_str(&format!(
                "{}. **{obl}** — {} -> {}\n",
                i + 1,
                f.message,
                f.fix.as_deref().unwrap_or(""),
            ));
        }
        md.push('\n');
    }

    md.push_str("---\n\n");
    md.push_str("*Generated by Complior — EU AI Act Compliance Tool*\n");

    md
}

/// Export report to a Markdown file.
pub fn export_report(scan: &ScanResult) -> Result<String, String> {
    let md = generate_report_markdown(scan);

    // Generate filename with date
    let now = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();
    let days = now / 86400;
    // Approximate date for filename
    let year = 1970 + days / 365;
    let remaining = days % 365;
    let month = remaining / 30 + 1;
    let day = remaining % 30 + 1;
    let filename = format!("COMPLIANCE-REPORT-{year}-{month:02}-{day:02}.md");

    std::fs::write(&filename, &md).map_err(|e| format!("Failed to write {filename}: {e}"))?;
    Ok(filename)
}

/// Render the Report View.
pub fn render_report_view(frame: &mut Frame, area: Rect, app: &App) {
    let t = theme::theme();
    let block = Block::default()
        .title(" Report ")
        .title_style(theme::title_style())
        .borders(Borders::ALL)
        .border_style(Style::default().fg(t.border));
    let inner = block.inner(area);
    frame.render_widget(block, area);

    let Some(scan) = &app.last_scan else {
        let lines = vec![
            Line::raw(""),
            Line::from(Span::styled(
                "  No scan data. Press Ctrl+S to scan first.",
                Style::default().fg(t.muted),
            )),
        ];
        frame.render_widget(Paragraph::new(lines).wrap(Wrap { trim: false }), inner);
        return;
    };

    let report_md = generate_report_markdown(scan);
    let md_lines = markdown::parse_markdown(&report_md);

    let mut lines: Vec<Line<'_>> = Vec::new();

    // Export status
    match &app.report_view.export_status {
        ExportStatus::Done(path) => {
            lines.push(Line::from(Span::styled(
                format!("  Exported: {path}"),
                Style::default().fg(t.zone_green),
            )));
            lines.push(Line::raw(""));
        }
        ExportStatus::Error(err) => {
            lines.push(Line::from(Span::styled(
                format!("  Export error: {err}"),
                Style::default().fg(t.zone_red),
            )));
            lines.push(Line::raw(""));
        }
        ExportStatus::None => {}
    }

    lines.extend(md_lines);

    // Hints
    lines.push(Line::raw(""));
    lines.push(Line::from(vec![
        Span::styled("  [e] ", Style::default().fg(t.accent)),
        Span::styled("Export as Markdown  ", Style::default().fg(t.muted)),
        Span::styled("[j/k] ", Style::default().fg(t.accent)),
        Span::styled("Scroll", Style::default().fg(t.muted)),
    ]));

    let scroll = app.report_view.scroll_offset;
    let paragraph = Paragraph::new(lines)
        .wrap(Wrap { trim: false })
        .scroll((scroll, 0));
    frame.render_widget(paragraph, inner);
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::ScoreBreakdown;

    fn make_scan() -> ScanResult {
        ScanResult {
            score: ScoreBreakdown {
                total_score: 72.0,
                zone: Zone::Yellow,
                category_scores: vec![],
                critical_cap_applied: false,
                total_checks: 20,
                passed_checks: 14,
                failed_checks: 6,
                skipped_checks: 0,
            },
            findings: vec![crate::types::Finding {
                check_id: "OBL-001".to_string(),
                r#type: "compliance".to_string(),
                message: "Missing AI disclosure".to_string(),
                severity: crate::types::Severity::Critical,
                obligation_id: Some("OBL-001".to_string()),
                article_reference: Some("Art. 50(1)".to_string()),
                fix: Some("Add disclosure".to_string()),
            }],
            project_path: "/test/project".to_string(),
            scanned_at: "2026-02-18".to_string(),
            duration: 1500,
            files_scanned: 42,
        }
    }

    #[test]
    fn test_generate_report_has_sections() {
        let scan = make_scan();
        let report = generate_report_markdown(&scan);
        assert!(report.contains("# Compliance Report"));
        assert!(report.contains("## Executive Summary"));
        assert!(report.contains("## Critical Findings"));
        assert!(report.contains("## All Findings"));
        assert!(report.contains("## Remediation Plan"));
    }

    #[test]
    fn test_zone_label() {
        assert_eq!(zone_label(Zone::Green), "GREEN (Compliant)");
        assert_eq!(zone_label(Zone::Yellow), "YELLOW (Partial)");
        assert_eq!(zone_label(Zone::Red), "RED (Non-compliant)");
    }

    #[test]
    fn test_report_view_no_scan() {
        crate::theme::init_theme("dark");
        let backend = ratatui::backend::TestBackend::new(80, 24);
        let mut terminal = ratatui::Terminal::new(backend).expect("terminal");
        let app = crate::app::App::new(crate::config::TuiConfig::default());

        terminal
            .draw(|frame| render_report_view(frame, frame.area(), &app))
            .expect("render");
    }
}
